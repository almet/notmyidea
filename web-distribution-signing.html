<!DOCTYPE html>
<html lang="fr">
    <head>
        <title>
Web distribution&nbsp;signing - Alexis Métaireau        </title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet"
              href="https://blog.notmyidea.org/theme/css/main.css?v2"
              type="text/css" />
        <link href="https://blog.notmyidea.org/feeds/all.atom.xml"
              type="application/atom+xml"
              rel="alternate"
              title="Alexis Métaireau ATOM Feed" />
    </head>
    <body>
        <div id="content">
            <section id="links">
                <ul>
                            <li>
                                <a class="main" href="/">Alexis Métaireau</a>
                            </li>
                        <li>
                            <a class=""
                               href="https://blog.notmyidea.org/journal/index.html">Journal</a>
                        </li>
                        <li>
                            <a class="selected"
                               href="https://blog.notmyidea.org/code/">Code, etc.</a>
                        </li>
                        <li>
                            <a class=""
                               href="https://blog.notmyidea.org/weeknotes/">Notes hebdo</a>
                        </li>
                        <li>
                            <a class=""
                               href="https://blog.notmyidea.org/lectures/">Lectures</a>
                        </li>
                        <li>
                            <a class=""
                               href="https://blog.notmyidea.org/projets.html">Projets</a>
                        </li>
                </ul>
            </section>

<header>
	<h1 class="post-title">Web distribution&nbsp;signing</h1>
	<p><em>Bringing trust back between software authors and user agents.</em></p>
	<time datetime="2015-10-12T00:00:00+02:00">12 octobre 2015</time>

    
</header>
<article>
    <p><em>I&#8217;m not a crypto expert, nor pretend to be one. These are thoughts I
want to share with the crypto community to actually see if any solution
exists to solve this particular&nbsp;problem.</em></p>
<p>One <a href="http://www.tonyarcieri.com/whats-wrong-with-webcrypto">often pointed</a> flaw in
web-based cryptographic applications is the fact that there is no way to
trust online software distributions. Put differently, you don&#8217;t actually
trust the software authors but are rather trusting the software
distributors and certificate authorities&nbsp;(CAs).</p>
<p>I&#8217;ve been talking with a few folks in the past months about that and
they suggested me to publish something to discuss the matter. So here I&nbsp;come!</p>
<h2 id="the-problem-attack-vectors">The problem (Attack&nbsp;vectors)</h2>
<p>Let&#8217;s try to describe a few potential&nbsp;attacks:</p>
<p><em>Application Authors</em> just released a new version of their open source
web crypto messaging application. An <em>Indie Hoster</em> installs it on their
servers so a wide audience can actually use&nbsp;it.</p>
<p>Someone alters the files on <em>Indie Hoster</em> servers, effectively
replacing them with other <em>altered files</em> with less security properties
/ a backdoor. This someone could either be an <em>Evil Attacker</em> which
found its way trough, the <em>Indie Hoster</em> or a <span class="caps">CDN</span> which delivers the&nbsp;files,</p>
<p>Trusted <em>Certificate Authorities</em> (&#8220;governments&#8221; or &#8220;hacking team&#8221;) can
also trick the User Agents (i.e. Firefox) into thinking they&#8217;re talking
to <em>Indie Hoster</em> even though they&#8217;re actually talking to a different&nbsp;server.</p>
<p><strong>Altered files</strong> are then being served to the User Agents, and <em>Evil
Attacker</em> now has a way to actually attack the end&nbsp;users.</p>
<h2 id="problem-mitigation">Problem&nbsp;Mitigation</h2>
<p>Part of the problem is solved by the recently introduced <a href="https://w3c.github.io/webappsec/specs/subresourceintegrity/">Sub Resource
Integrity</a>
(<span class="caps">SRI</span>). To quote them: &#8220;[it] defines a mechanism by which user agents
may verify that a fetched resource has been delivered without unexpected&nbsp;manipulation.&#8221;.</p>
<p><span class="caps">SRI</span> is a good start, but isn&#8217;t enough: it ensures the assets (JavaScript
files, mainly) loaded from a specific <span class="caps">HTML</span> page are the ones the author
of the <span class="caps">HTML</span> page intends. However, <span class="caps">SRI</span> doesn&#8217;t allow the User Agent to
ensure the <span class="caps">HTML</span> page is the one he&nbsp;wants.</p>
<p>In other words, we miss a way to create trust between <em>Application
Authors</em> and <em>User Agents</em>. The User-Agent currently has to trust the
<em>Certificate Authorities</em> and the delivery (<em>Indie Hoster</em>).</p>
<p>For desktop software distribution: <em>Crypto Experts</em> audit the software,
sign it somehow and then this signature can be checked locally during
installation or runtime. It&#8217;s not automated, but at least it&#8217;s&nbsp;possible.</p>
<p>For web applications, we don&#8217;t have such a mechanism, but it should be
possible. Consider the&nbsp;following:</p>
<ul>
<li><em>App Authors</em> publish a new version of their software; They provide
    a hash of each of their distributed files (including the <span class="caps">HTML</span>&nbsp;files);</li>
<li><em>Crypto Experts</em> audit these files and sign the hashes&nbsp;somehow;</li>
<li><em>User Agents</em> can chose to trust some specific <em>Crypto Experts</em>;</li>
<li>When a <em>User Agent</em> downloads files, it checks if they&#8217;re signed by
    a trusted&nbsp;party.</li>
</ul>
<h2 id="chosing-who-you-trust">Chosing who you&nbsp;trust</h2>
<p>In terms of user experience, handling certificates is hard, and that&#8217;s
where the community matters. Distributions such as
<a href="https://tails.boom.org">Tails</a> could chose who they trust to verify the
files, and issue warnings / refuse to run the application in case files
aren&#8217;t&nbsp;verified.</p>
<p>But, as highligted earlier, CAs are hard to trust. A new instance of the
same <span class="caps">CA</span> system wouldn&#8217;t make that much differences, expect the fact that
distributions could ship with a set of trusted authorities (for which
revocation would still need to be taken care&nbsp;of).</p>
<blockquote>
<p>[&#8230;] users are vulnerable to MitM attacks by the authority, which
can vouch for, or be coerced to vouch for, false keys. This weakness
has been highlighted by recent <span class="caps">CA</span> scandals. Both schemes can also be
attacked if the authority does not verify keys before vouching for&nbsp;them.</p>
<p>&#8212; <a href="http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf">SoK : Secure
Messaging</a>;</p>
</blockquote>
<p>It seems that some other systems could allow for something more&nbsp;reliable:</p>
<blockquote>
<p>Melara et al proposed <span class="caps">CONIKS</span>, using a series of chained commitments to
Merkle prefix trees to build a key directory [&#8230;] for which
individual users can efficiently verify the consistency of their own
entry in the directory without relying on a third&nbsp;party.</p>
<p>This “self- auditing log” approach makes the system partially have no
auditing required (as general auditing of non-equivocation is still
required) and also enables the system to be privacy preserving as the
entries in the directory need not be made public. This comes at a mild
bandwidth cost not reflected in our table, estimated to be about 10
kilobytes per client per day for&nbsp;self-auditing.</p>
<p>&#8212; <a href="http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf">SoK : Secure
Messaging</a>;</p>
</blockquote>
<p>Now, I honestly have no idea if this thing solves the whole problem, and
I&#8217;m pretty sure this design has many security problems attached to&nbsp;it.</p>
<p>However, that&#8217;s a problem I would really like to see solved one day, so
here the start of the discussion, don&#8217;t hesitate to <a href="/pages/about.html">get in
touch</a>!</p>
<h2 id="addendum">Addendum</h2>
<p>It seems possible to increase the level a user has in a Web Application
by adding indicators in the User-Agent. For instance, when using an
application that&#8217;s actually signed by someone considered trustful by the
User-Agent (or the distributor of the User-Agent), a little green icon
could be presented to the User, so they know that they can be confident
about&nbsp;this.</p>
<p>A bit like User-Agents do for <span class="caps">SSL</span>, but for the actual signature of the
files being&nbsp;viewed.</p>
</article>
            <footer>
                <a id="feed" href="/feeds/all.atom.xml">
                    <img alt="RSS Logo" src="/theme/rss.svg" />
                </a>
            </footer>
        </div>
    </body>
</html>